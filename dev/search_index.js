var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API","title":"API","text":"Modules = [Jevo]","category":"page"},{"location":"api/#Jevo._WeightCache","page":"API","title":"Jevo._WeightCache","text":"We identify weights of a layer by their dimensions and the last gene id used to generate them.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.AllVsAllMatchMaker","page":"API","title":"Jevo.AllVsAllMatchMaker","text":"AllVsAllMatchMaker(ids::Vector{String}=String[];kwargs...)\n\nCreates an Operator that creates all vs all matches between individuals in populations with ids in ids.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Assertor-Tuple{}","page":"API","title":"Jevo.Assertor","text":"Assertor(;kwargs...)\n\nCreates an Operator that asserts some condition. You probably want to override the retriever operator fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.ClearInteractionsAndRecords","page":"API","title":"Jevo.ClearInteractionsAndRecords","text":"ClearInteractionsAndRecords(;kwargs...)\n\nClears all interactions and records from all individuals in the state.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.CloneUniformReproducer","page":"API","title":"Jevo.CloneUniformReproducer","text":"CloneUniformReproducer(pop_size::Int, ids::Vector{String}=String[]; kwargs...)\n\nCreates an Operator that choose individuals uniformly at random and clones them, creating children with identical DNA, until the population reaches pop_size individuals.\n\nShould be used after a selector.\n\nSee also: TruncationSelector\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.CompositePopulation","page":"API","title":"Jevo.CompositePopulation","text":"CompositePopulation(id::String, populations::Vector{<:AbstractPopulation})\n\nA population composed of subpopulations. Can be used to hierarchically organize populations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.ComputeInteractions!","page":"API","title":"Jevo.ComputeInteractions!","text":"\n\n\n\n","category":"type"},{"location":"api/#Jevo.Counter","page":"API","title":"Jevo.Counter","text":"Counter(type::Type)\n\nHolds an integer to increase by 1 with inc!(counter::Counter). Used for tracking gene ids, generations, individual ids, etc. Counters have a default value of 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.CreateMissingWorkers","page":"API","title":"Jevo.CreateMissingWorkers","text":"Creates up to n workers\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Creator","page":"API","title":"Jevo.Creator","text":"struct Creator{T} <: AbstractCreator where T\n    type::Type{T}\n    kwargs::Union{NamedTuple,Tuple}\nend\n\nA creator is a struct that contains a type to create and the arguments to pass to the constructor. If arguments contain other creators, those are recursively created first, unless enclosed in a PassThrough. We use a creator to allow for creating multiple objects which may include random initialization with a single creator.\n\nSee also: PassThrough, create\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Delta","page":"API","title":"Jevo.Delta","text":"Delta{G} <: AbstractGenotype where {G <: AbstractGenotype}\n\nA delta is a change in a genotype. It can be applied to a genotype to create a new genotype, with the differences applied.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.GenePool","page":"API","title":"Jevo.GenePool","text":"GenePool(deltas::Vector)\n\nA gene pool is a collection of deltas.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.GenerationIncrementer-Tuple{}","page":"API","title":"Jevo.GenerationIncrementer","text":"GenerationIncrementer(;kwargs...)\n\nIncrements the generation counter in the state by 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.Individual","page":"API","title":"Jevo.Individual","text":"mutable struct Individual{G,D,I} <: AbstractIndividual where \n    {G <: AbstractGenotype,\n     D <: AbstractCreator,\n     I <: AbstractInteraction}\n    id::Int\n    generation::Int\n    parents::Vector{Int}\n    genotype::G\n    developer::D\n    records::Vector{AbstractRecord}\n    interactions::Vector{I}\n    data::Vector\nend\n\nAn individual is a single entity in the population. Each individual should have a unique id generated from an AbstractIndividual Counter. An individual's developer is a creator that turns a genotype into a phenotype. \n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Individual-Tuple{Vector{<:AbstractCounter}, Creator, AbstractCreator}","page":"API","title":"Jevo.Individual","text":"Individual(counters::Vector{<:AbstractCounter},\n           genotype_creator::Creator,\n           developer::AbstractCreator)\n\nCreate new individual with no parents\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.InitializeAllPopulations","page":"API","title":"Jevo.InitializeAllPopulations","text":"Samples 1 population from each population creator and puts them into state.populations\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.InitializeDeltaCache","page":"API","title":"Jevo.InitializeDeltaCache","text":"InitializeDeltaCache(ids::Vector{String}=String[];kwargs...)\n\nCreates a cache of Deltas for a population.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.InitializePhylogeny","page":"API","title":"Jevo.InitializePhylogeny","text":"InitializePhylogeny(ids::Vector{String}=String[];kwargs...)\n\nInitializes a phylogenetic tree for populations with ids in ids. The tree is initialized with the current generation's individuals as the genesis individuals. The tree is initialized only once, and will throw an error if called multiple times on the same population.\n\nSee also LogPhylogeny, UpdatePhylogeny, PurgePhylogeny\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.LogPhylogeny","page":"API","title":"Jevo.LogPhylogeny","text":"LogPhylogeny(ids::Vector{String}=String[]; kwargs...)\n\nAdds recent individuals to a phylogeny file called $(pop.id)-phylo.csv in the current directory. The file is formatted as a CSV with columns id and ancestor_list, according to the ALIFE Data Standard\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Match","page":"API","title":"Jevo.Match","text":"struct Match{I,E} <: AbstractMatch where {I <: AbstractIndividual, E <: AbstractEnvironment}\n    id::Int\n    individuals::Vector{I}\n    environment_creator::Creator{E}\nend\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.MaxMRs","page":"API","title":"Jevo.MaxMRs","text":"Consists of a genotype with at most one gene per weight.  Each gene has the largest MR in the genepool for that weight. The ids, seeds, and inits are irrelevant for these.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Mutator","page":"API","title":"Jevo.Mutator","text":"Mutator(ids::Vector{String}=String[]; time::Bool=false, condition=always, kwargs...)\n\nOperator that mutates the genotypes of individuals in populations with ids in ids. Calls mutate! on each individual in each population.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Operator","page":"API","title":"Jevo.Operator","text":"Operator <: AbstractOperator\n\nAll operator structs should be defined with the @define_op macro, and all operators should be created with the create_op function. Each operator should have the following fields:\n\ncondition::Function\nretriever::Union{Function, AbstractRetriever}\noperator::Function\nupdater::Union{Function, AbstractUpdater}\ndata::Vector{<:AbstractData}\ntime::Bool\n\ncondition is a function that takes the state and returns a boolean. If condition(state) == false, the operator will not be executed. Ex: always, first_gen\n\nretriever is a function/object that takes the state and the operator and returns an object or list of objects to operate on. Should not update state. Ex: get_individuals, PopulationRetriever\n\noperator is a function that takes the state and the retrieved object(s) and returns the modified object(s). Should perform none or trivial state updates, like incrementing a counter. Ex: Jevo.make_all_v_all_matches\n\nupdater is a function/object that takes the state and the modified object(s) and updates the state. Ex: ReccordAdder!, ComputeInteractions!\n\ndata is a vector of data objects that can be stored in the operator. Currently unused.\n\ntime is a boolean that determines if the time taken to execute the operator should be logged. Defaults to false\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.PassThrough","page":"API","title":"Jevo.PassThrough","text":"struct PassThrough <: AbstractCreator\n    creator::AbstractCreator\nend\n\nA PassThrough is a struct that contains a creator to create. When the first create call is made, say on a population, the passthrough creator will return the creator, instead of actually performing the creation. This allows us to pass through genotype creators and developers to instantiated populations without creating them.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Performer","page":"API","title":"Jevo.Performer","text":"        Performer <: AbstractOperator\n\nRuns all matches in state.matches, and adds interactions to the individuals in the matches. This operator is intended to be used after a MatchMaker has created matches.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.PopSizeAssertor","page":"API","title":"Jevo.PopSizeAssertor","text":"PopSizeAssertor(size::Int, pop_ids::Vector{String}=String[];kwargs...)\n\nAsserts each population with an id in pop_ids has size individuals.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Population","page":"API","title":"Jevo.Population","text":"Population(id::String, individuals::Vector{<:AbstractIndividual})\n\nCreate a population with a given id and individuals.\n\nPopulation(id::String, individuals::Vector{<:AbstractIndividual}) =\n\nCreate pop with predefined inds and no data\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.PopulationAdder!","page":"API","title":"Jevo.PopulationAdder!","text":"PopulationAdder!()\n\nCreates an Updater that adds populations to the state.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.PopulationCreatorRetriever","page":"API","title":"Jevo.PopulationCreatorRetriever","text":"Retreives all creators of type AbstractPopulation from state.creators\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.PopulationRetriever","page":"API","title":"Jevo.PopulationRetriever","text":"Retrieves Vector{Vector{AbstractIndividual}} from state\n\nFor example, a two-pop all vs all matchmaker with the following population hierarchy: \n\necosystem\n├── composite1\n│   ├── pop1a: ind1a1, ind1a2\n│   └── pop1b: ind1b1, ind1b2\n└── composite2\n    ├── pop2a: ind2a1, ind2a2\n    └── pop2b: ind2b1, ind2b2\n\nids = [\"ecosystem\"] or [] will fetch:     [inds1a1, ind1a2, ind1b1, ind1b2, ind2a1, ind2a2, ind2b1, ind2b2]]\n\nids = [\"composite1\"] will fetch: [ind1a1, ind1a2, ind1b1, ind1b2]]\n\nids = [\"pop1a\"] will fetch: [[ind1a1, ind1a2]]\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.PopulationRetriever-Tuple{AbstractState, Vararg{Any}}","page":"API","title":"Jevo.PopulationRetriever","text":"Traverses the population tree and returns references to all vectors of individuals to an arbitrary depth. If ids is not empty, it only returns individuals from the specified populations\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.PopulationUpdater!","page":"API","title":"Jevo.PopulationUpdater!","text":"PopulationUpdater!(;ids=String[])\n\nCurrently unimplemented.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.PurgePhylogeny","page":"API","title":"Jevo.PurgePhylogeny","text":"PurgePhylogeny(ids::Vector{String}=String[];kwargs...)\n\nPurges the phylogenetic tree for populations with ids in ids. Removes individuals from the phylogenetic tree that with no living descendants.\n\nSee also LogPhylogeny, InitializePhylogeny, UpdatePhylogeny\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.RandomEvaluator","page":"API","title":"Jevo.RandomEvaluator","text":"RandomEvaluator(ids::Vector{String}=String[]; kwargs...)\n\nOperator that record with a random fitness score to each individual in populations with ids in ids. Typically used for testing.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.ReccordAdder!","page":"API","title":"Jevo.ReccordAdder!","text":"ReccordAdder!(;ids=String[])\n\nCreates an Updater that adds records to individuals in populations with ids in ids.\n\nfunction(adder::ReccordAdder!)(state::AbstractState, records::Vector{<:Vector{<:Vector{<:AbstractRecord}}})\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.Reporter","page":"API","title":"Jevo.Reporter","text":"Reporter(;kwargs...)\n\nReporter(type::Type{<:AbstractMetric}; h5=true, txt=true, console=false, kwargs...)\n\nOperator that \"reports\" some aspect of the state to either the console, a text file, or an hdf5 file. Allows us to log or record data anywhere in the pipeline.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.ScalarFitnessEvaluator","page":"API","title":"Jevo.ScalarFitnessEvaluator","text":"ScalarFitnessEvaluator(ids::Vector{String}=String[]; kwargs...)\n\nOperator that computes the scalar fitness of each individual in populations with ids in ids. Requires all individuals to have at least one interaction.\n\nThe scalar fitness is the mean of the scores of each interaction, shifted by the minimum score. \n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.SoloMatchMaker","page":"API","title":"Jevo.SoloMatchMaker","text":"\n\n\n\n","category":"type"},{"location":"api/#Jevo.State","page":"API","title":"Jevo.State","text":"mutable struct State <: AbstractState\n    id::String\n    rng::AbstractRNG\n    creators::Vector{AbstractCreator}\n    operators::Vector{AbstractOperator}\n    populations::Vector{AbstractPopulation}\n    counters::Vector{AbstractCounter}\n    matches::Vector{AbstractMatch}\n    data::Vector    # for extensions\nend\n\nA mutable struct which holds all runtime data for an evolutionary simulation. See [`State(rng::AbstractRNG, creators::Vector{<:AbstractCreator}, operators::Vector{<:AbstractOperator})`](@ref) . each generation.\n\nExample\n\nusing Jevo, StableRNGs\nrng = StableRNG(1)\n\nk = 1\nn_dims = 2\nn_inds = 2\nn_species = 2\nn_gens = 10\n\ncounters = default_counters()\nng_genotype_creator = Creator(VectorGenotype, (n=n_dims,rng=rng))\nng_developer = Creator(VectorPhenotype)\n\ncomp_pop_creator = Creator(CompositePopulation, (\"species\", [(\"p$i\", n_inds, ng_genotype_creator, ng_developer) for i in 1:n_species], counters))\nenv_creator = Creator(CompareOnOne)\n\nstate = State(\"ng_phylogeny\", rng,[comp_pop_creator, env_creator],\n    [InitializeAllPopulations(),\n    AllVsAllMatchMaker(),\n    Performer(),\n    ScalarFitnessEvaluator(),\n    TruncationSelector(k),\n    CloneUniformReproducer(n_inds),\n    Mutator(),\n    ClearInteractionsAndRecords(),\n    Reporter(GenotypeSum, console=true)], counters=counters)\n\nrun!(state, n_gens)\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.State-Tuple{String, Random.AbstractRNG, Vector{<:AbstractCreator}, Vector{<:AbstractOperator}}","page":"API","title":"Jevo.State","text":"State(\n    id::String,\n    rng::AbstractRNG,\n    creators::Vector{<:AbstractCreator},\n    operators::Vector{<:AbstractOperator};\n    counters::Vector{<:AbstractCounter}=default_counters(),\n    populations::Vector{<:AbstractPopulation}=AbstractPopulation[],\n    matches::Vector{<:AbstractMatch}=AbstractMatch[],\n    data::Vector=[],\n)\n\nStates are created from a random number generator, a list of creators, and a list of operators, and usually a list of counters.\n\ncreators should have at least on population creator and one environment creator. operators should contain an operator for each step of the evolutionary process. counters should contain a generation counter, individual id counter, gene counter, and match counter. All creators/operators should refer to the counter objects in state.\n\nUse generation(state) to get the current generation number, initialized to one. The GenerationIncrementer operator is automatically appended to the operator list to advance the state to the next generation. Individuals created without any parents are of generation 0.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.TruncationSelector","page":"API","title":"Jevo.TruncationSelector","text":"TruncationSelector <: AbstractSelector\n\nSelects the top k individuals from a population based on their fitness scores, purging the rest. The individuals are sorted by their fitness scores in descending order, and the top k individuals are selected. If there are fewer than k individuals in the population, raises an error.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.UpdateDeltaCache","page":"API","title":"Jevo.UpdateDeltaCache","text":"UpdateDeltaCache(ids::Vector{String}=String[];kwargs...)\n\nUpdates the DeltaCache for a population with the current generation's individuals.\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.UpdateGenePool","page":"API","title":"Jevo.UpdateGenePool","text":"UpdateGenePool(ids::Vector{String}=String[]; after_gen::Int, n_latest::Int, time::Bool=false, kwargs...)\n\nAfter generation after_gen, updates the gene pool for populations with ids in ids with the n_latest most recent deltas. \n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.UpdatePhylogeny","page":"API","title":"Jevo.UpdatePhylogeny","text":"UpdatePhylogeny(ids::Vector{String}=String[];kwargs...)\n\nUpdates the phylogenetic tree for populations with ids in ids. The tree is updated with the current generation's individuals as children of their parents. If an individual has no parent or more than one parent, an error is thrown.\n\nSee also LogPhylogeny, InitializePhylogeny, PurgePhylogeny\n\n\n\n\n\n","category":"type"},{"location":"api/#Jevo.WeightsCollection","page":"API","title":"Jevo.WeightsCollection","text":"A collection of weights which are concatenated together.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.map!-Tuple{Function, Jevo.AbstractLayer}","page":"API","title":"Base.map!","text":"map!(f::Function, x::AbstractLayer)\n\nApply a function to all weights in a neural network.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, Vector{<:AbstractJevo}}","page":"API","title":"Base.show","text":"Override Base.show to avoid printing empty containers\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.add_matches!-Tuple{AbstractState, Vector{Jevo.Match}}","page":"API","title":"Jevo.add_matches!","text":"add_matches!(state::AbstractState, matches::Vector{Match})\n\nUpdater which adds matches to the state.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.always-Tuple{AbstractState}","page":"API","title":"Jevo.always","text":"Condition for operators that should run each generation\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.clone-Tuple{AbstractState, AbstractIndividual}","page":"API","title":"Jevo.clone","text":"clone(state::AbstractState, parent::AbstractIndividual)\n\nCreate a child with the same genotype as the parent, but with the id, generation, and parent changed.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.copyarchitecture-Tuple{Any}","page":"API","title":"Jevo.copyarchitecture","text":"Recursively makes copy of network architecture without copying the individual genes.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.create-Tuple{AbstractState, Any}","page":"API","title":"Jevo.create","text":"create(x)\n\nCalls create on all elements of x that are creators, and returns x otherwise. This recursively instantiates all creators. If a creator is enclosed in a PassThrough, the PassThrough wrapper is removed, and the creator is kept as is. \n\ncreate(::AbstractState, x): Calls create(x), can be used in an Operator.   create(c::AbstractCreator): Calls the creator function c.   create(args::Tuple): Recursively creates elements of the tuple.   create(kwargs::NamedTuple): Recursively creates values of the named tuple.   create(cs::Vector{<:AbstractCreator}): Calls create for each element in the vector of creators.   create(x): Returns x if x is not a creator and does not contain a creator\n\nAll calls to create eventually lead, someway or another, to a call to the following constructor\n\n(creator::Creator{T})() where T = T(create(creator.kwargs)...)\n\nwhich creates the object of type T with the arguments in creator.kwargs.\n\nSee also: Creator, PassThrough\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.create_op-Tuple{Type{<:AbstractOperator}}","page":"API","title":"Jevo.create_op","text":"create_op(\n    type::Union{Type{<:AbstractOperator}, String};\n    condition=always,\n    retriever=noop,\n    operator=noop,\n    updater=noop,\n    data=AbstractData[],\n    time=false,\n    additional_fields...\n)\n\nCreate an Operator of type type with the specified fields. All fields are optional. The retriever, operator, and updater fields default to noop.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.find-Tuple{Symbol, Any, Vector}","page":"API","title":"Jevo.find","text":"find(attr::Symbol, match::Any, v::Vector)\n\nFind the first element in v where el.attr == match. Used for finding counters of a specific type.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.first_gen-Tuple{AbstractState}","page":"API","title":"Jevo.first_gen","text":"first_gen(state::AbstractState)\n\nReturn true if the current generation is 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.generation-Tuple{AbstractState}","page":"API","title":"Jevo.generation","text":"generation(state::AbstractState)\n\nReturn the current generation number of the state stored in the AbstractGeneration counter.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.get_counter-Tuple{Type, AbstractState}","page":"API","title":"Jevo.get_counter","text":"get_counter(type::Type, state::AbstractState)\n\nReturns the counter of the given type in the state.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.get_individuals-Tuple{AbstractState, Vararg{Any}}","page":"API","title":"Jevo.get_individuals","text":"get_individuals(state::AbstractState, args...)\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.get_opponent_ids_2player-Tuple{Jevo.Match, Int64}","page":"API","title":"Jevo.get_opponent_ids_2player","text":"Get id of other individual in a 2-player match\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.getonly-Tuple{Any, Union{Tuple, Vector}}","page":"API","title":"Jevo.getonly","text":"getonly(f, itr::Union{Vector, Tuple})\n\nReturns the only element in itr that satisfies the predicate f. If there are no elements or more than one element, an error is thrown.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.inc!-Tuple{Counter}","page":"API","title":"Jevo.inc!","text":"inc!(counter::Counter, n::Int=1)\n\nIncrement the value of the given counter by n in a thread-safe manner. Returns the value of before the increment.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.make_all_v_all_matches-Tuple{AbstractState, Vector{Vector{Population}}}","page":"API","title":"Jevo.make_all_v_all_matches","text":"make_all_v_all_matches(state::AbstractState, pops::Vector{Vector{Population}})\n\nReturns a vector of Matches between all pairs of individuals in the populations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.mutate!-Tuple{Random.AbstractRNG, AbstractState, AbstractPopulation, AbstractIndividual}","page":"API","title":"Jevo.mutate!","text":"mutate!(rng::AbstractRNG, state::AbstractState, population::AbstractPopulation, genotype::AbstractGenotype; kwargs...)\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.noop-Tuple{}","page":"API","title":"Jevo.noop","text":"noop([x...])\n\nReturns the arguments passed\n\nnoop(::AbstractState, x)\n\nReturns x. Used to perform no operation for retrievers, operators, and updaters.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.run!-Tuple{State, Int64}","page":"API","title":"Jevo.run!","text":"run!(state::State, max_generations::Int)\n\nBegin/continue evolution until generation max_generations\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.skip-Tuple{Vector}","page":"API","title":"Jevo.skip","text":"skip iterating over certain hierarchical configurations. We currently use this to\n\navoid iterating over the embedding weights for both the Embed and EmbedDecoder layers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.verify_weights_collection-Union{Tuple{BD}, Tuple{Tuple{Vararg{Int64}}, BD}} where BD<:Matrix{Tuple{Int64, Int64}}","page":"API","title":"Jevo.verify_weights_collection","text":"Confirms that each row of weights has the same # of rows in each weight, and each column has the same number of columns.\n\n\n\n\n\n","category":"method"},{"location":"api/#Jevo.@define_op","page":"API","title":"Jevo.@define_op","text":"@define_op name [supertype=AbstractOperator, additional_fields=\"\"]\n\nDefines a a subtype of supertype called name with the following fields:\n\ncondition\nretriever\noperator\nupdater\ndata\ntime\n\nSee Operator for more information.\n\nExample\n\n@define_op \"AllVsAllMatchMaker\" \"AbstractMatchMaker\"\n\n\n\n\n\n","category":"macro"},{"location":"miscellaneous/#Miscellaneous-Bits","page":"Miscellaneous","title":"Miscellaneous Bits","text":"","category":"section"},{"location":"miscellaneous/#Checkpointing","page":"Miscellaneous","title":"Checkpointing","text":"","category":"section"},{"location":"miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"The Checkpointer operator serializes the state to disk. As the state contains every part of an evolutionary simulation (except per-worker caches), this is sufficient to resume from a checkpoint.","category":"page"},{"location":"miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"For checkpointing, you can use the following pattern for state creation:","category":"page"},{"location":"miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"checkpointname = \"check.jls\"\nstate = isfile(checkpointname) ? restore_from_checkpoint(checkpointname) :\n          State(\"example\", rng, creators::Vector{<:AbstractCreator}, \n            [Checkpointer(checkpointname, interval=25),\n            # other operators...\n            ]","category":"page"},{"location":"miscellaneous/#SLURM","page":"Miscellaneous","title":"SLURM","text":"","category":"section"},{"location":"miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"Jevo.jl supports distributed computing on SLURM clusters. Jevo currently only supports GPU workers on a single node, but will support distributed computing across nodes in the future.","category":"page"},{"location":"miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"[CreateMissingWorkers","category":"page"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Each step of an evolutionary algorithm is represented by an Operator. The @define_op macro defines new operator structs with fields specified in the operator documentation. The create_op function generates new operator objects with default values for unspecified operator fields. This section provides an overview of the operators implemented so far in Jevo.jl.","category":"page"},{"location":"operators/#Retrievers","page":"Operators","title":"Retrievers","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Retrievers are a struct or function that, retrieve data from the state. ","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Jevo.PopulationCreatorRetriever, used in InitializeAllPopulations\nPopulationRetriever, used in AllVsAllMatchMaker, and many others\nget_individuals, used in ClearInteractionsAndRecords","category":"page"},{"location":"operators/#Updaters","page":"Operators","title":"Updaters","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Jevo.ComputeInteractions!, used in Performer\nPopulationAdder, used in InitializeAllPopulations\nPopulationUpdater, currently unused because I forgot to use it \nJevo.add_matches!, used in AllVsAllMatchMaker and SoloMatchMaker\nJevo.RecordAdder, used in ScalarFitnessEvaluator","category":"page"},{"location":"operators/#Matchmaker","page":"Operators","title":"Matchmaker","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"AllVsAllMatchMaker\nSoloMatchMaker, individuals play a match alone, used for evolutionary computing","category":"page"},{"location":"operators/#Evaluators","page":"Operators","title":"Evaluators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"ScalarFitnessEvaluator\nRandomEvaluator","category":"page"},{"location":"operators/#Selectors","page":"Operators","title":"Selectors","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"TruncationSelector","category":"page"},{"location":"operators/#Reproducers","page":"Operators","title":"Reproducers","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"CloneUniformReproducer","category":"page"},{"location":"operators/#Performer","page":"Operators","title":"Performer","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Performer","category":"page"},{"location":"operators/#Mutators","page":"Operators","title":"Mutators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Mutator, uses Jevo.mutate as its .operator.","category":"page"},{"location":"operators/#Assertors","page":"Operators","title":"Assertors","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Assertors are operators that you can add at any point in the pipeline to check that certain aspects of the state are as expected.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"PopSizeAssertor","category":"page"},{"location":"operators/#Reporters","page":"Operators","title":"Reporters","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Reporter, can log data if Jevo.measure for a specified Jevo.AbstractMetric as its .operator.","category":"page"},{"location":"operators/#Checkpointer","page":"Operators","title":"Checkpointer","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Checkpointer","category":"page"},{"location":"operators/#Initializers","page":"Operators","title":"Initializers","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"InitializeAllPopulations, uses Jevo.create as its .operator.","category":"page"},{"location":"operators/#Miscellaneous","page":"Operators","title":"Miscellaneous","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"CreateMissingWorkers. SLURM compatible, but only for a single node.","category":"page"},{"location":"operators/#Phylogenies","page":"Operators","title":"Phylogenies","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"See Phylogeny","category":"page"},{"location":"extensibility/#Extensibility","page":"Extensibility","title":"Extensibility","text":"","category":"section"},{"location":"extensibility/","page":"Extensibility","title":"Extensibility","text":"Jevo is designed to be easily extensible. This means minimizing the number of new variants of structures a future user would need to implement. For example, with Phylogenies, we didn't need to implement a new type of population that contains a phylogenetic tree. This has a few benefits:","category":"page"},{"location":"extensibility/","page":"Extensibility","title":"Extensibility","text":"Dramatic reduction in number of types, and consequently, the lines of code.\nExtensions work better with each other if they use the same types.\nThe user can focus on the new functionality they want to add, rather than the boilerplate code.","category":"page"},{"location":"extensibility/","page":"Extensibility","title":"Extensibility","text":"The way we achieve this is, frankly, by using \"bad\" practices very carefully, adding various checks (and documentation) to prevent misuse. So far, we've experienced fewer bugs than expected with our extension system.","category":"page"},{"location":"extensibility/#Additional-Data","page":"Extensibility","title":"Additional Data","text":"","category":"section"},{"location":"extensibility/","page":"Extensibility","title":"Extensibility","text":"States, Populations, and Individuals can store additional data in their .data field, which is a vector Any. Operators at one point in the pipeline can write data objects to these fields, which later operators can look up use. ","category":"page"},{"location":"extensibility/","page":"Extensibility","title":"Extensibility","text":"For example, we add a PhylogeneticTree object to each population, taking care to ensure that one and only one tree exists a time. The InitializePhylogeny operator creates the tree at the start of a run and adds it to a population's .data. The UpdatePhylogeny operator looks up this tree and updates it after a new generation is created.","category":"page"},{"location":"extensibility/","page":"Extensibility","title":"Extensibility","text":"Jevo.jl provides some barebones functionality for ensuring correctness. A key function is getonly(f, itr::Union{Vector,Tuple}), which will return the only object in a vector/tuple that makes f, return true. If there are no objects or more than one object that satisfies f, an error is thrown. In the Phylogeny system, this ensures that only one tree exists per population.","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Jevo is designed to be simple yet flexible (co-)evolutionary computing framework, with the core package under 2500 LOC. The framework is broken up into four core concepts:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A State is a structure that holds all information about the evolutionary process.\nOperators are functions/structs that update the state. Jevo breaks down evolutionary algorithms into a series of sequential operators which are applied to the simulator state.\nA Creator is a structure that generates new objects with specified parameters, and are called by operators. Creators spawn populations, individuals, genotypes, environments, other creators, and more.\nAll other standard evolutionary objects (Individual, Population, genotypes, phenotypes, environments, etc.) which are contained in the State.","category":"page"},{"location":"overview/#Numbers-Game-Example","page":"Overview","title":"Numbers Game Example","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The simplest way to get started with Jevo is by example. We'll use The Numbers Game as our example domain, which consists of two co-evolving populations of vectors. For an example which focuses on neuroevolution, see the TODO example.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"using Jevo\nusing Logging\nusing StableRNGs\n\n# Jevo provides a custom logger to easily store statistical measurements to \n# an HDF5 file, print to console, and log text to a file.\nglobal_logger(JevoLogger())\nrng = StableRNG(1)\n\nk = 2          # How many individuals to keep each generation\nn_dims = 2     # Number of dimensions in the vector\nn_inds = 10    # Number of individuals in each population\nn_species = 2  # Number of species\nn_gens = 10    # Number of generations\n\n# We create a list of counters which are incremented \n# to track individuals, genes, generations, and matches.\n# This is passed to the state constructor.\ncounters = default_counters()\n\n# Instead of creating genotypes and phenotypes directly, we create a\n# genotype creator, which generates genotypes, and a phenotype creator,\n# which \"develops\" a genotype into a phenotype.\nng_genotype_creator = Creator(VectorGenotype, (n=n_dims,rng=rng))\nng_developer = Creator(VectorPhenotype)\n\n# Likewise, instead of creating populations directly, we create a population\n# creator, which generates populations. Here, we create a composite population,\n# which is a population of sub-populations. Each sub-population is a species.\ncomp_pop_creator = Creator(CompositePopulation, (\"species\", [(\"p$i\", n_inds, ng_genotype_creator, ng_developer) for i in 1:n_species], counters))\n\n# An environment creator can be used to generate instances of an environment,\n# particulary useful for randomizing the environment.\nenv_creator = Creator(CompareOnOne)\n\n# We create a state called \"ng_phylogeny\" with the RNG object we passed to our creators.\n# We initialize the state with a list of creators (order does not matter), and\n# a list of operators (order does matter). Operators will look for creators by\n# type when needed to generate new objects when appropriate.\nstate = State(\"ng_phylogeny\", rng,[comp_pop_creator, env_creator],\n    [InitializeAllPopulations(),\n     InitializePhylogeny(),\n    AllVsAllMatchMaker(),\n    Performer(),\n    ScalarFitnessEvaluator(),\n    TruncationSelector(k),\n    CloneUniformReproducer(n_inds),\n    Mutator(),\n    PopSizeAssertor(n_inds),\n    ClearInteractionsAndRecords(),\n    Reporter(GenotypeSum, console=true)], counters=counters)\n\n# We run the state for n_gens generations.\nrun!(state, n_gens)","category":"page"},{"location":"overview/#Design-Philosophy","page":"Overview","title":"Design Philosophy","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Minimize architectural complexity, maximize code reuse.\nTrade-off efficiency for simplicity whenever possible, except for performance-critical code. Don't be afraid to recompute things to avoid bookkeeping or use existing inefficient solution if it doesn't noticably impact performance.\nAll Counters use the highest level appropriate type (AbstractIndividual, AbstractGene, etc).\nrandn is faster for Float32 than Float16, so we use Float32 for weights, despite the added memory cost.\nAny multi-threaded operation that uses state.rng should generate a new RNG object for each iteration or thread in the main process, to ensure that the same random numbers are not used in different threads.\nWhen using Distributed, all evaluations are done on workers and other evolutionary operations are done on the main process. When not using Distributed, all operations are done on the main process.","category":"page"},{"location":"phylogeny/#Phylogeny","page":"Phylogeny","title":"Phylogeny","text":"","category":"section"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"We use PhylogeneticTrees.jl for phylogeny tracking. This package includes efficient algorithms for calculating distances between taxa and pruning the tree of taxa with no living descendants to free up memory.","category":"page"},{"location":"phylogeny/#Why-do-we-care-about-Phylogeny?","page":"Phylogeny","title":"Why do we care about Phylogeny?","text":"","category":"section"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"In short, phylogeny is the evolutionary history of a group of organisms. This has myriad uses:","category":"page"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"Analysis: We can easily observe how population dynamics change throughout evolution and visualize extinctions and sub-species\nOptimization: We can estimate performance of individuals based on their phylogenetic distance from other individuals to achieve substantial reductions in compute required. See evolutionary and co-evolutionary applications of this idea.","category":"page"},{"location":"phylogeny/#Phylogenetic-Operators","page":"Phylogeny","title":"Phylogenetic Operators","text":"","category":"section"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"Phylogeny is managed using four operators:","category":"page"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"InitializePhylogeny: Adds current members of the population as roots of a phylogenetic tree. Runs on the first generation\nUpdatePhylogeny: Updates the phylogeny for the current population, runs on all generations. Should run after children are produced.\nLogPhylogeny: A bit misnamed for now, this operator writes phylogeny data to disk in the ALIFE Data Standard format. Should run before pruning individuals\nPurgePhylogeny: Removes individuals from the phylogeny that have no living descendants. Should run after children are produced and optionally, all individuals have been written to disk. Essential for reducing memory usage.","category":"page"},{"location":"phylogeny/#Deltas-and-DeltaCaches","page":"Phylogeny","title":"Deltas and DeltaCaches","text":"","category":"section"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"Stores the difference between an individual and its parent for all edges in the tree.","category":"page"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"InitializeDeltaCache: Initializes the delta cache for the current population. Runs on the first generation.\nUpdateDeltaCache: Updates the delta cache for the current population. Should run after children are produced.","category":"page"},{"location":"phylogeny/#Gene-Pool","page":"Phylogeny","title":"Gene Pool","text":"","category":"section"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"The GenePool is a subset of genes in the population, typically the most recent genes. Used for runtime techniques that leverage information about the population, like adaptive mutation rates.","category":"page"},{"location":"phylogeny/","page":"Phylogeny","title":"Phylogeny","text":"UpdateGenePool: Creates/updates the gene pool for the current population.","category":"page"},{"location":"#Jevo.jl","page":"Home","title":"Jevo.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Jevo.jl, a julia package for distributed, high-performance (co-)evolutionary computation, inspired by CoEvo. While Jevo is flexible enough to support most evolutionary/co-evolutionary algorithms and organisms, it is designed specifically for distributed deep neuroevolution. Only one selection method has been implemented so far. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"We highly recommend reviewing Overview for a high-level introduction to the package's core concepts, functionality, and design.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"overview.md\", \"operators.md\", \"phylogeny.md\", \"extensibility.md\", \"miscellaneous.md\"]","category":"page"}]
}
